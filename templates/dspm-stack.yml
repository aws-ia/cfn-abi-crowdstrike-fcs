AWSTemplateFormatVersion: "2010-09-09"
Description: Create assumable role for CrowdStrike Data Analysis
Parameters:
  ClientID:
    Type: String
    NoEcho: true
    Description: CrowdStrike client ID
    MinLength: "1"
  ClientSecret:
    Type: String
    NoEcho: true
    Description: CrowdStrike client secret
    MinLength: "1"
  CSRoleName:
    Description: Name of CrowdStrike assuming role
    Type: String
    MinLength: "10"
  CSAccountNumber:
    Description: CrowdStrike account number
    Type: String
    MinLength: "12"
    MaxLength: "12"
  ExternalID:
    Type: String
    Description: Unique ID for tenant
    MinLength: "32"
  ScannerRoleName:
    Type: String
    Description: The unique name of the IAM role that CrowdStrike Scanner will be assuming
    Default: CrowdStrikeDSPMScannerRole
  DSPMRoleName:
    Type: String
    Description: The unique name of the IAM role that CrowdStrike will be assuming
    Default: CrowdStrikeDSPMIntegrationRole
  DSPMRegions:
    Type: String
    Description: comma separated list of regions to enable, e.g. us-east-1,us-west-2
    AllowedPattern: "^((\\s*)((?:us|eu|ap|sa|ca|af|me|il)-(?:north|south|east|west|central|northeast|southeast|southwest|northwest)-[1-4])(\\s*)(?:,|$))+$"
    Default: us-east-1
    MinLength: "1"
Mappings:
  TagMap:
    CrowdStrikeTag:
      Value: CrowdStrike
    DeploymentRegions:
      Key: CrowdStrikeDeploymentRegions
    LogicalTag:
      Name: CrowdStrikeLogicalId
  # Lambda:
  #   CloudformationTemplateURL:
  #     Value: https://cs-prod-cloudconnect-templates.s3.amazonaws.com/aws_cspm_cloudformation_dspm_env.yaml

Resources:
  # Creates instance profile. Attached as IAM role to EC2 instance, used for data scan
  ClientSecrets:
    Type: AWS::SecretsManager::Secret
    Metadata:
      checkov:
        skip:
          - id: CKV_AWS_149
            comment: The default key aws/secretsmanager is sufficient to secure this resource
    Properties:
      Name:  "CrowdStrikeDSPMClientSecret"
      SecretString: !Sub |
        {
          "ClientId": "${ClientID}",
          "ClientSecret": "${ClientSecret}"
        }
      Tags:
        - Key: ProvisionedBy
          Value: !FindInMap [ TagMap, CrowdStrikeTag, Value ]
        - Key: !FindInMap [ TagMap, LogicalTag, Name ]
          Value: ClientSecrets
  # Creates instance profile. Attached as IAM role to EC2 instance, used for data scan
  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    DependsOn:
      - CrowdStrikeAWSScannerRole
    Properties:
      InstanceProfileName: CrowdStrikeDSPMScannerRoleProfile
      Path: /
      Roles:
        - !Ref ScannerRoleName
  CrowdStrikeAWSIntegrationRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyWildcardResource # Role has * to allow for future service monitoring without stack updates
            - EIAMPolicyActionWildcard # Role has * to allow for future service monitoring without stack updates
      checkov:
        skip:
          - id: CKV_AWS_109
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_111
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_108
            comment: Read only permissions required for integration to function.
    Properties:
      RoleName: !Ref DSPMRoleName
      Path: /
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${CSAccountNumber}:role/${CSRoleName}" 
            Condition:
              StringEquals:
                sts:ExternalId: !Ref ExternalID
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/SecurityAudit"
      Tags:
        - Key: ProvisionedBy
          Value: !FindInMap [ TagMap, CrowdStrikeTag, Value ]
      Policies:
        - PolicyName: CrowdStrikeCloudScanSupplemental
          PolicyDocument:
            Statement:
              - Action:
                  - ses:DescribeActiveReceiptRuleSet
                  - athena:GetWorkGroup
                  - logs:DescribeLogGroups
                  - elastictranscoder:ListPipelines
                  - elasticfilesystem:DescribeFileSystems
                  - redshift:List*
                  - redshift:Describe*
                  - redshift:View*
                  - redshift-serverless:List*
                  - ec2:GetConsoleOutput
                  - sts:DecodeAuthorizationMessage
                  - elb:DescribeLoadBalancers
                  - cloudwatch:GetMetricData
                  - cloudwatch:GetMetricStatistics
                  - cloudwatch:ListMetrics
                Effect: Allow
                Resource: '*'

        - PolicyName: CrowdStrikeRDSClone
          PolicyDocument:
            Statement:
              # Grants permission to add only requested tag mentioned in condition to RDS instance and snapshot
              - Sid: RDSPermissionForTagging
                Action:
                  - rds:AddTagsToResource
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:db:crowdstrike-*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:snapshot:crowdstrike-*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster:crowdstrike-*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:crowdstrike-*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to restore CMK encrypted instances
              - Sid: KMSPermissionsForRDSRestore
                Action:
                  - kms:Encrypt
                  - kms:Decrypt
                  - kms:ReEncrypt*
                  - kms:GenerateDataKey*
                  - kms:CreateGrant
                  - kms:ListGrants
                  - kms:DescribeKey
                Effect: Allow
                Resource: '*'
                Condition:
                  StringLike:
                    "kms:ViaService": "rds.*.amazonaws.com"

              # Grants permission to restore an instance/cluster from any snapshot
              - Sid: RDSPermissionForInstanceRestore
                Action:
                  - rds:RestoreDBInstanceFromDBSnapshot
                  - rds:RestoreDBClusterFromSnapshot
                  - kms:Decrypt # Require to restore encrypted db snapshot using KMS keys
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:snapshot:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:*"
                  - !Sub "arn:aws:kms:*:${AWS::AccountId}:key/*"

              # Restricts permission to restore an instance/cluster to CrowdStrike VPC
              - Sid: RDSPermissionForInstanceRestoreCrowdStrikeVPC
                Action:
                  - rds:RestoreDBInstanceFromDBSnapshot
                  - rds:RestoreDBClusterFromSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:subgrp:*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to restore instance/cluster with a tag mentioned in the condition
              - Sid: RDSLimitedPermissionForInstanceRestore
                Action:
                  - rds:RestoreDBInstanceFromDBSnapshot
                  - rds:RestoreDBClusterFromSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:db:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster:*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:security-group/*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:og:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:pg:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-og:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-pg:*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to create snapshot with a tag mentioned in the condition.
              - Sid: RDSLimitedPermissionForSnapshotCreate
                Action:
                  - rds:CreateDBSnapshot
                  - rds:CreateDBClusterSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:db:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:snapshot:crowdstrike-*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:crowdstrike-*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to copy snapshot with a tag mentioned in the condition.
              - Sid: RDSLimitedPermissionForCopySnapshot
                Action:
                  - rds:CopyDBSnapshot
                  - rds:CopyDBClusterSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:snapshot:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to create db instance with a tag mentioned in the condition inside db cluster
              - Sid: RDSPermissionDBClusterCreateInstance
                Action:
                  - rds:CreateDBInstance
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:db:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Restricts create db instance permission to CrowdStrike VPC
              - Sid: RDSPermissionDBClusterCreateInstanceCrowdStrikeVPC
                Action:
                  - rds:CreateDBInstance
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:subgrp:*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to delete or modify RDS DB/cluster, which are tagged as mentioned in the condition
              - Sid: RDSPermissionDeleteRestorePermissions
                Action:
                  - rds:DeleteDBInstance
                  - rds:DeleteDBSnapshot
                  - rds:ModifyDBInstance
                  - rds:DeleteDBCluster
                  - rds:DeleteDBClusterSnapshot
                  - rds:ModifyDBCluster
                  - rds:RebootDBInstance
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:db:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:snapshot:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-snapshot:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:og:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:pg:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-og:*"
                  - !Sub "arn:aws:rds:*:${AWS::AccountId}:cluster-pg:*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

        - PolicyName: CrowdStrikeRedshiftClone
          PolicyDocument:
            Statement:
              # Grants permission to create a cluster snapshot and restore cluster from snapshot
              - Sid: RedshiftPermissionsForRestoring
                Action:
                  - redshift:RestoreFromClusterSnapshot
                  - redshift:CreateClusterSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:redshift:*:${AWS::AccountId}:cluster:*"
                  - !Sub "arn:aws:redshift:*:${AWS::AccountId}:snapshot:*"

              # Grants permission to create tags, modify and delete CrowdStrike's clusters and snapshots
              - Sid: RedshiftPermissionsForControllingClones
                Action:
                  - redshift:CreateTags
                  - redshift:ModifyCluster*
                  - redshift:DeleteCluster
                  - redshift:DeleteClusterSnapshot
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:redshift:*:${AWS::AccountId}:cluster:crowdstrike-*"
                  - !Sub "arn:aws:redshift:*:${AWS::AccountId}:snapshot:*/crowdstrike-snapshot-*"

              # Grants permission to secret manager to restore redshift's password managed by secret manager
              - Sid: RedshiftPermissionsForSecretsManager
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:TagResource
                  - secretsmanager:DescribeSecret
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:secretsmanager:*:${AWS::AccountId}:secret:*"

        - PolicyName: RunDataScannerRestricted
          PolicyDocument:
            Statement:
              # Grants permission to start, terminate EC2 and attach, detach, delete volume
              # on CrowdStrike EC2 instance
              - Sid: AllowInstanceOperationsWithRestrictions
                Action:
                  - ec2:StartInstances
                  - ec2:TerminateInstances
                  - ec2:RebootInstances
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:instance/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:volume/*"
                Condition:
                  StringEquals:
                    "ec2:ResourceTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to launch EC2 from public image
              # Below resources are generic as they are not known during launch
              - Sid: AllowRunDistrosInstances
                Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - "arn:aws:ec2:*::image/*"
                  - "arn:aws:ec2:*::snapshot/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:volume/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:network-interface/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:security-group/*"

              # Grants permission to Launch EC2 and create volume for CrowdStrike EC2 instance
              # The condition key aws:RequestTag is applicable to below resources
              - Sid: AllowRunInstancesWithRestrictions
                Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:instance/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:volume/*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]

              # Grants permission to create below resources with only CrowdStrike tag
              # on CrowdStrike EC2 instance
              - Sid: AllowCreateTagsOnlyLaunching
                Action:
                  - ec2:CreateTags
                Effect: Allow
                Resource:
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:instance/*"
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:volume/*"
                Condition:
                  StringEquals:
                    "aws:RequestTag/ProvisionedBy": !FindInMap [ TagMap, CrowdStrikeTag, Value ]
                    "ec2:CreateAction": [ "RunInstances" ]

              # Grant permissions to attach instance profile for EC2 service created by CrowdStrike
              - Sid: passRoleToEc2Service
                Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !Join [ "/", [ !Sub "arn:aws:iam::${AWS::AccountId}:role", !Ref ScannerRoleName ] ]
                Condition:
                  StringEquals:
                    iam:PassedToService: ec2.amazonaws.com

              - Sid: ssmAmiAliasPermissions
                Action:
                  - ssm:GetParameters
                Effect: Allow
                Resource:
                  - '*'

  CrowdStrikeAWSScannerRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyWildcardResource # Role has * to allow for future service monitoring without stack updates
            - EIAMPolicyActionWildcard # Role has * to allow for future service monitoring without stack updates
      checkov:
        skip:
          - id: CKV_AWS_109
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_111
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_108
            comment: Read only permissions required for integration to function.
          - id: CKV_AWS_107
            comment: Read only permissions required for integration to function.
    Properties:
      RoleName: !Ref ScannerRoleName
      Path: /
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/CloudWatchLogsReadOnlyAccess"
        - "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
      Tags:
        - Key: ProvisionedBy
          Value: !FindInMap [ TagMap, CrowdStrikeTag, Value ]
      Policies:
        # Grants logs reading to use inside our instance profile
        - PolicyName: CrowdStrikeLogsReader
          PolicyDocument:
            Statement:
              - Action:
                  - rds:DownloadDBLogFilePortion
                  - rds:DownloadCompleteDBLogFile
                  - rds:DescribeDBLogFile
                  - logs:ListTagsLogGroup
                  - logs:DescribeQueries
                  - logs:GetLogRecord
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:DescribeSubscriptionFilters
                  - logs:StartQuery
                  - logs:DescribeMetricFilters
                  - logs:StopQuery
                  - logs:TestMetricFilter
                  - logs:GetLogDelivery
                  - logs:ListLogDeliveries
                  - logs:DescribeExportTasks
                  - logs:GetQueryResults
                  - logs:GetLogEvents
                  - logs:FilterLogEvents
                  - logs:DescribeQueryDefinitions
                  - logs:GetLogGroupFields
                  - logs:DescribeResourcePolicies
                  - logs:DescribeDestinations
                Effect: Allow
                Resource: '*'

        # Grants bucket reading to use inside our instance profile
        - PolicyName: CrowdStrikeBucketReader
          PolicyDocument:
            Statement:
              - Action:
                  - s3:Get*
                  - s3:List*
                Effect: Allow
                Resource: '*'

        # Grants DynamoDB reading to use inside our instance profile
        - PolicyName: CrowdStrikeDynamoDBReader
          PolicyDocument:
            Statement:
              - Action:
                  - dynamodb:BatchGet*
                  - dynamodb:Describe*
                  - dynamodb:List*
                  - dynamodb:Get*
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:PartiQLSelect
                Effect: Allow
                Resource: '*'

        # Grants Redshift reading to use inside our instance profile
        - PolicyName: CrowdStrikeRedshiftReader
          PolicyDocument:
            Statement:
              - Action:
                  - redshift:List*
                  - redshift:Describe*
                  - redshift:View*
                  - redshift:Get*
                  - redshift-serverless:List*
                  - redshift-serverless:Get*
                Effect: Allow
                Resource: '*'

        # Grants SecretManager reading to get client id and secret
        - PolicyName: CrowdStrikeSecretReader
          PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:ListSecrets
                Effect: Allow
                Resource: '*'

  CloudformationServiceRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyWildcardResource # Role has * to allow for future service monitoring without stack updates
            - EIAMPolicyActionWildcard # Role has * to allow for future service monitoring without stack updates
      checkov:
        skip:
          - id: CKV_AWS_109
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_111
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_108
            comment: Read only permissions required for integration to function.
    Properties:
      RoleName: "CrowdStrikeDSPMCloudformationServiceRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - cloudformation.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Policies:
        - PolicyName: createDSPMEnvironmentResources
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: getPublicParams
                Effect: Allow
                Action:
                  - ssm:GetParameter*
                Resource:
                  - !Sub "arn:${AWS::Partition}:ssm:*::parameter/aws*"
              - Sid: manageRolePolicies
                Effect: Allow
                Action:
                  - iam:AttachRolePolicy
                  - iam:DeleteRolePolicy
                  - iam:CreatePolicy
                  - iam:DeletePolicy
                  - iam:PutRolePolicy
                  - iam:TagRole
                  - iam:ListRoleTags
                  - iam:UntagRole

                Resource: "*"
              - Sid: createDeleteVpcs
                Effect: Allow
                Action:
                  - ec2:AllocateAddress
                  - ec2:AssociateRouteTable
                  - ec2:AttachInternetGateway
                  - ec2:CreateTags
                  - ec2:CreateVpc
                  - ec2:CreateInternetGateway
                  - ec2:CreateNatGateway
                  - ec2:CreateSecurityGroup
                  - ec2:CreateSubnet
                  - ec2:CreateRouteTable
                  - ec2:CreateRoute
                  - ec2:Describe*
                  - ec2:DisassociateRouteTable
                  - ec2:DeleteInternetGateway
                  - ec2:DeleteNatGateway
                  - ec2:DeleteRouteTable
                  - ec2:DeleteRoute
                  - ec2:DeleteSubnet
                  - ec2:DeleteSecurityGroup
                  - ec2:DeleteTags
                  - ec2:DeleteVpc
                  - ec2:DetachInternetGateway
                  - ec2:DetachNetworkInterface
                  - ec2:List*
                  - ec2:ModifyVpcAttribute
                  - ec2:ReleaseAddress
                  - ec2:AuthorizeSecurityGroupIngress
                Resource: "*"
              - Sid: dbScanningSupport
                Effect: Allow
                Action:
                  - rds:Describe*
                  - rds:CreateDBSubnetGroup
                  - rds:DeleteDBSubnetGroup
                  - rds:ModifyDBSubnetGroup
                  - rds:AddTagsToResource
                  - redshift:Describe*
                  - redshift:CreateClusterSubnetGroup
                  - redshift:DeleteClusterSubnetGroup
                  - redshift:CreateTags
                  - redshift:ModifyClusterSubnetGroup
                Resource: "*"
              - Sid: kmsPermissions
                Effect: Allow
                Action:
                  - kms:*
                Resource: "*"

  CustomResourceRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyWildcardResource # Role has * to allow for future service monitoring without stack updates
            - EIAMPolicyActionWildcard # Role has * to allow for future service monitoring without stack updates
      checkov:
        skip:
          - id: CKV_AWS_109
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_111
            comment: IAM PassRole action is constrained by resource ARN.
          - id: CKV_AWS_108
            comment: Read only permissions required for integration to function.
    Properties:
      RoleName: "DSPMLambdaRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Policies:
        - PolicyName: customResourceRequirements
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: createDeleteSubstacks
                Effect: Allow
                Action:
                  - cloudformation:CreateStack
                  - cloudformation:CreateChangeSet
                  - cloudformation:ExecuteChangeSet
                  - cloudformation:UpdateStack
                  - cloudformation:DeleteStack
                  - cloudformation:Describe*
                  - cloudformation:List*
                Resource: "*"
              - Sid: passrole
                Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt CloudformationServiceRole.Arn
              - Sid: writeLogs
                Effect: Allow
                Action:
                  - logs:*
                Resource: "*"
              - Sid: createDeleteKMS
                Effect: Allow
                Action:
                  - kms:CancelKeyDeletion
                  - kms:CreateAlias
                  - kms:CreateKey
                  - kms:DescribeKey
                  - kms:DeleteAlias
                  - kms:EnableKey
                  - kms:ReplicateKey
                  - kms:ScheduleKeyDeletion
                  - kms:TagResource
                Resource: "*"
              - Sid: manageState
                Effect: Allow
                Action:
                  - ssm:PutParameter
                  - ssm:GetParameter
                  - ssm:DeleteParameter
                Resource: "*"
              - Sid: tagRole
                Effect: Allow
                Action:
                  - iam:ListRoleTags
                  - iam:UntagRole
                  - iam:TagRole
                Resource: "*"
              - Sid: secretPermissions
                Effect: Allow
                Action:
                  - secretsmanager:TagResource
                  - secretsmanager:DescribeSecret
                Resource: "*"
              - Sid: s3permissions
                Effect: Allow
                Action:
                  - s3:*
                Resource: "*"

  CreateEnvironmentLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks: 
            - W2531 # Engineering planning on upgrading this function soon
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Lambda custom resource only run during stack lifecycle events.
          - id: W92
            reason: Lambda custom resource only run during stack lifecycle events.
      checkov:
        skip:
          - id: CKV_AWS_115
            comment: Lambda does not need reserved concurrent executions.
          - id: CKV_AWS_116
            comment: DLQ not needed, as Lambda function only triggered by CloudFormation events.
          - id: CKV_AWS_117
            comment: Lambda does not need to communicate with VPC resources.
          - id: CKV_AWS_173
            comment: Environment variables are not sensitive.
    Properties:
      FunctionName: CrowdStrikeDSPMCreateEnvironmentLambda
      Description: Lambda function for the implementation of nested stacks
      Handler: index.lambda_handler
      MemorySize: 128
      Runtime: python3.12
      Role: !GetAtt 'CustomResourceRole.Arn'
      Timeout: 900
      Code:
        ZipFile: |
          # https://repost.aws/knowledge-center/cloudformation-lambda-resource-delete
          import boto3
          import cfnresponse
            
          failure_statuses = ['CREATE_FAILED', 'DELETE_FAILED', 'UPDATE_FAILED', 'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
          'UPDATE_ROLLBACK_COMPLETE', 'ROLLBACK_COMPLETE', 'ROLLBACK_FAILED', 'UPDATE_ROLLBACK_FAILED']
          
          
          def create_env(event, client, stack_name, env_cloudformation_url):
            # idempotence
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              if len(result['Stacks']) != 0:
                return result['Stacks'][0]
            
            except Exception as e:
              # if the stack does not yet exist, proceed to create
              pass
            
            params = create_template_params(event)
            client.create_stack(
              StackName=stack_name,
              TemplateURL=env_cloudformation_url,
              DisableRollback=True,
              Capabilities=['CAPABILITY_IAM'],
              Parameters=params,
              RoleARN=event['ResourceProperties']['CloudformationRole']
            )
            
            try:
              waiter = client.get_waiter('stack_create_complete')
              waiter.wait(
                StackName=stack_name,
                WaiterConfig={
                  'Delay': 15,
                  'MaxAttempts': 100
                }
              )
            
            except Exception:
              # if operation failed, we will see failure status when we describe stack
              pass
            
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              
              if len(result['Stacks']) == 0:
                raise Exception(f"No stack {stack_name} found")
              
              return result['Stacks'][0]
            
            except Exception as e:
              stack_status = "CREATE_FAILED"
              stack_status_reason = f"Error retrieving stack {stack_name}: {str(e)}"
              return {"StackStatus": stack_status, "StackStatusReason": stack_status_reason}
          
          
          def delete_env(event, client, stack_name):
            # idempotence
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              
              if len(result['Stacks']) == 0:
                raise Exception(f"No stack {stack_name} found")
            
            except Exception:
              # if stack does not exist
              return
            
            try:
              client.delete_stack(
                StackName=stack_name,
                RoleARN=event['ResourceProperties']['CloudformationRole']
              )
              
              waiter = client.get_waiter('stack_delete_complete')
              waiter.wait(
                StackName=stack_name,
                WaiterConfig={
                  'Delay': 15,
                  'MaxAttempts': 100
                }
              )
            
            except Exception:
              # if operation failed, we will see failure status when we describe stack
              pass
            
            # check if stack still exists
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              
              # if operation failed, return stack will show failure status
              if len(result['Stacks']) != 0:
                return result['Stacks'][0]
            
            except Exception:
              pass
            
            stack_status = "DELETE_COMPLETE"
            stack_status_reason = f"Stack {stack_name} deleted successfully"
            return {"StackStatus": stack_status, "StackStatusReason": stack_status_reason}
          
          
          def update_env(event, client, stack_name, env_cloudformation_url):
            # check if stack exists
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              if len(result['Stacks']) == 0:
                raise Exception("Stack does not exists")
            
            
            except Exception:
              # if stack does not exist, create stack
              response = create_env(event, client, stack_name, env_cloudformation_url)
              if response['StackStatus'] in failure_statuses:
                # if creation fails, delete before update rollback
                delete_env(event, client, stack_name)
              return response
            
            try:
              # update stack
              params = create_template_params(event)
              client.update_stack(
                StackName=stack_name,
                TemplateURL=env_cloudformation_url,
                Capabilities=['CAPABILITY_IAM'],
                Parameters=params,
                RoleARN=event['ResourceProperties']['CloudformationRole']
              )
              
              waiter = client.get_waiter('stack_update_complete')
              waiter.wait(
                StackName=stack_name,
                WaiterConfig={
                  'Delay': 15,
                  'MaxAttempts': 100
                }
              )
            
            except Exception:
              # if there are no updates for this stack, continue
              pass
            
            # get the stack
            try:
              result = client.describe_stacks(
                StackName=stack_name
              )
              
              if len(result['Stacks']) == 0:
                raise Exception(f"Stack {stack_name} not found after update")
              
              return result['Stacks'][0]
            
            except Exception as e:
              stack_status = "UPDATE_FAILED"
              stack_status_reason = str(e)
              return {"StackStatus": stack_status, "StackStatusReason": stack_status_reason}
          
          
          def update_regions_tag(event, regions_string):
              sm_client = boto3.client('secretsmanager')
              regions_string_formatted = regions_string.replace(",", "/")
              tags = [
                {
                  'Key': event['ResourceProperties']['RegionsTagKey'], 
                  'Value': regions_string_formatted
                }
              ]
              sm_client.tag_resource(SecretId=event['ResourceProperties']['SecretId'], Tags=tags)
          
          
          def get_regions_tag(event):
            sm_client = boto3.client('secretsmanager')
            response = sm_client.describe_secret(SecretId=event['ResourceProperties']['SecretId'])
            tags = response['Tags']
            deployment_regions = None
            for tag in tags:
              if tag['Key'] == event['ResourceProperties']['RegionsTagKey']:
                deployment_regions = tag['Value']
            if deployment_regions is None:
              raise Exception(f"No {event['ResourceProperties']['RegionsTagKey']} tag found on client secret")
            return deployment_regions
          
          
          def create_template_params(event):
            return [
              {
                "ParameterKey": "CrowdStrikeIntegrationRoleName",
                "ParameterValue": event['ResourceProperties']['RoleName'],
              },
              {
                "ParameterKey": "CrowdStrikeScannerRoleName",
                "ParameterValue": event['ResourceProperties']['ScannerRoleName'],
              }
            ]
          
          
          def create_regions_list(regions_string, char):
            regions = regions_string.split(char)
            return [region.strip() for region in regions if region != ""]
          
          
          def send_response(message, context, cfn_status, event, reason):
            if event['RequestType'] == 'Update':
              cfnresponse.send(event, context, cfn_status, message, physicalResourceId=event['PhysicalResourceId'], reason=reason)
              return
            
            cfnresponse.send(event, context, cfn_status, message, reason=reason)
          
          
          def lambda_handler(event, context):
            # create variables
            failed_stacks = ""
            stack_names = ""
            source_stack_name = ""
            success_message = {"Message": "Operation successful"}
            failure_message = {"Message": "Operation failed"}
          
            try:
              # get template URL
              env_cloudformation_url = event['ResourceProperties']['CloudformationTemplateURL']
              
              # get regions
              regions_string = event['ResourceProperties']['Regions']
              regions = create_regions_list(regions_string, ',')
              
              # get source stack name
              split_stack_id = event['StackId'].split('/')
              if len(split_stack_id) == 3:
                source_stack_name = split_stack_id[1]
              else:
                raise Exception("Parent stack ID format invalid")
              
              # delete previous deployment regions on update request
              if event['RequestType'] == 'Update':
                previous_regions_string = get_regions_tag(event)
                previous_regions = create_regions_list(previous_regions_string, '/')
                regions_to_delete = [region for region in previous_regions if region not in regions]
                
                # delete regions that have been removed in update request
                for region in regions_to_delete:
                  client = boto3.client('cloudformation', region_name=region)
                  # get stack name to delete
                  stack_name = '{}-substack-env-{}'.format(source_stack_name, region)
                  stack_names += f"{stack_name}, "
                  response = delete_env(event, client, stack_name)
                  
                  if response is None:
                    continue
                  
                  if response['StackStatus'] in failure_statuses:
                    failed_stacks += f"The stack {stack_name} failed to {event['RequestType']}. Failure reason: {response['StackStatusReason']} "
          
              # for each region, create substack for scanning environment
              for region in regions:
                  client = boto3.client('cloudformation', region_name=region)
      
                  # get stack name
                  stack_name = '{}-substack-env-{}'.format(source_stack_name, region)
                  stack_names += f"{stack_name}, "
      
                  if event['RequestType'] == 'Create':
                      response = create_env(event, client, stack_name, env_cloudformation_url)
                  if event['RequestType'] == 'Update':
                      response = update_env(event, client, stack_name, env_cloudformation_url)
                  elif event['RequestType'] == 'Delete':
                      response = delete_env(event, client, stack_name)
      
                  if response is None:
                      continue
      
                  if response['StackStatus'] in failure_statuses:
                      failed_stacks += f"The stack {stack_name} failed to {event['RequestType']}. Failure reason: {response['StackStatusReason']} "
      
              if failed_stacks != "":
                  send_response(failure_message, context, cfnresponse.FAILED, event, failed_stacks)
                  return
      
              if event['RequestType'] != 'Delete':
                # update CrowdStrike deployment regions tag on secret
                update_regions_tag(event, regions_string)
      
              send_response(success_message, context, cfnresponse.SUCCESS, event, f"{event['RequestType']} successful. Substacks: {stack_names}")
              return
      
            except Exception as e:
                send_response(failure_message, context, cfnresponse.FAILED, event, f"An error occurred during {event['RequestType']} request: {str(e)}")
                return
        

  CreateEnvironments:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - CrowdStrikeAWSIntegrationRole
      - CrowdStrikeAWSScannerRole
    Properties:
      ServiceToken: !GetAtt CreateEnvironmentLambda.Arn
      RoleName: !Ref DSPMRoleName
      ScannerRoleName: !Ref ScannerRoleName
      CloudformationRole: !GetAtt CloudformationServiceRole.Arn
      RegionsTagKey: !FindInMap [TagMap, DeploymentRegions, Key]
      Regions: !Ref DSPMRegions
      SourceRegion: !Ref "AWS::Region"
      AccountId: AWS::AccountId
      SecretId: !Ref ClientSecrets
      CloudformationTemplateURL: !Sub https://${SourceS3BucketName}.s3.${S3BucketRegion}.amazonaws.com/${SourceS3BucketNamePrefix}/templates/aws_cspm_cloudformation_dspm_env.yml
